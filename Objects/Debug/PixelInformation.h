#pragma once
#include <glm/glm.hpp>
#include "../PipelineItem.h" // TODO: add_include_dirs(Objects)
#include "../../Engine/Model.h"

namespace ed
{
	class PixelInformation
	{
	public:
		PixelInformation() {
			Color = DebuggerColor = glm::vec4(0.0f);
			Owner = nullptr;
			Object = nullptr;
			Fetched = false;
			Discarded = false;
			VertexCount = 0;
			RenderTexture = "";
			RenderTextureIndex = 0;
			InstanceID = 0;
			VertexID = 0;
		}
		glm::vec4 Color; // actual pixel color
		glm::vec4 DebuggerColor; // Color generated by the debugger - this way users can see if the ShaderDebugger is executing code correctly... going to leave this here until I improve ShaderDebugger
	
		PipelineItem* Owner; // shader pass responsible for this pixel
		PipelineItem* Object; // pipeline item responsible for this pixel
		std::string RenderTexture; // what render texture
		int RenderTextureIndex;

		int VertexID;
		int InstanceID;

		glm::ivec2 Coordinate; // pixel position on the texture
		glm::vec2 RelativeCoordinate;

		bool Fetched; // Did we fill the DebuggerColor and Vertex[] information for this pixel?
		bool Discarded; // was this pixel discarded?
		
		int VertexCount; // 1 for point, 2 for line, 3 for triangle, etc...
		eng::Model::Mesh::Vertex Vertex[3]; // vertices that are responsible for this pixel
		std::unordered_map<std::string, bv_variable> VertexShaderOutput[3];
	};
}